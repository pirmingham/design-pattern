# 1,设计模式概述(分类重要11类重点掌握)

## 1.1产生背景

1995年正式推出23种设计模式的概念。

## 1.2设计模式的概念

设计模式是一套被前人总结的、反复使用的对于常见的特定问题的解决方案。它是一种解决问题的一系列套路。

## 1.3设计模式的分类（创界行）

### 创建者模式（单元建抽工）

将对象的使用与创建分离。

在**单元**门前**见**到一个很**丑**的**工**人

1. 单例★★☆
2. 原型★
3. 建造者★☆
4. 抽象工厂★★
5. 工厂方法★★☆

### 结构型模式（戴氏想祖乔装外）

将类或对象组成更大的结构

戴氏想祖父了，乔装打扮外出

1. 代理★★☆
2. 适配器★★☆
3. 享元
4. 组合
5. 桥接★
6. 装饰★★☆
7. 外观★★

### 行为型模式（访中观模命策职，迭备解装）

将类和对象组合去完成单个对象不能完成的任务，以及怎样分配职责。

**访**问**中**国去**观摩**却被**命**令**撤职**，**叠**起**备**忘录**解**开**状**书

1. 访问者
2. 中介者
3. 观察者★★☆
4. 模版方法★★☆
5. 命令★★
6. 策略★★☆
7. 职责链☆

1. 迭代器☆
2. 备忘录
3. 解释器
4. 状态★

# 2,UML图

## 2.1类的表示方式

在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 

![ ](https://gitee.com/pirmingham/gallery/raw/master/images/Employee.jpg)

属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：

* +：表示public
* -：表示private
* #：表示protected
* : 表示package

## 2.2类与类的关系

[身为程序员还看不懂UML类图？ 一文带你零基础学会看UML类图！-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/802969)

[UML类图新手入门级介绍-CSDN博客](https://blog.csdn.net/monkey_d_meng/article/details/6005764)

![类图](https://ucc.alicdn.com/images/user-upload-01/2021060600310099.png)

| 功能             | 图示  | 描述                | 举例                                                |
| ---------------- | ----- | ------------------- | --------------------------------------------------- |
| 继承关系         | ---▷  | 实线 + 空心三角形   | 鸟 ---▷ 动物；鸟继承动物                            |
| 实现接口         | •••▷  | 虚线 + 空心三角形   | 大雁 •••▷ 飞翔；大雁实现了飞翔接口                  |
| 实现接口         | ---○  | 棒棒糖表示法        | 唐老鸭 ---○ 讲人话；唐老鸭实现讲人话接口            |
| 关联关系         | --->  | 实线剪头            | 企鹅 ---> 气候；企鹅需要‘知道’气候的变化            |
| 依赖关系         | •••>  | 虚线剪头            | 动物 •••> 氧气；动物依赖于氧气                      |
| 聚合关系         | ◇---> | 空心菱形 + 实线剪头 | 大雁 ◇---> 雁群；A包含B，但B不是A的一部分           |
| 合成（组合）关系 | ◆---> | 实心菱形 + 实线剪头 | 大雁 ◆---> 翅膀；部分和整体的关系，部分不能独立存在 |

### 口诀：接虚空，聚空菱，依虚箭，

### 1实现关系[接-虚-空]

记忆：实现是虚线+空心三角形，三角形指向接口

### 2继承（泛化）关系[实]



### 3聚合关系[聚-空-菱]

记忆：聚合是实线+空心菱形，菱形指向整体

### 4组合关系[实]



### 5依赖关系[依-虚-箭]

记忆：依赖是虚线箭头，箭头指向依赖的东西

### 6关联关系[实]

**1，单向关联**

![](https://gitee.com/pirmingham/gallery/raw/master/images/customer_address.png)

在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。

**2，双向关联**

![ ](https://gitee.com/pirmingham/gallery/raw/master/images/customer_product.png)

从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。

在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。

**3，自关联**

![](https://gitee.com/pirmingham/gallery/raw/master/images/node.png)

自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。

# 3,软件设计原则(SOLID,CD)

## 1. S单一职责原则（Single Responsibility Principle）

### 概念

**一个类应该只有一个引起变化的原因。这意味着一个类应该只有一种责任。**

人话：每个类，或者每个接口，方法等某个维度，都应该仅包含相对独立的某个能力。

### 例子

假设我们有一个负责管理用户的类，它既负责用户的信息管理，又负责用户的权限验证。这违反了单一职责原则，因为用户信息管理和权限验证是两个不同的责任。

```java
// 违反单一职责原则的类
public class UserManager {
    // 用户信息管理的责任
    public void manageUserInformation(User user) {
        // 代码实现...
    }

    // 权限验证的责任
    public boolean validateUserPermissions(User user) {
        // 代码实现...
        return false;
    }
}
```

为了符合单一职责原则，我们可以将这两个责任拆分为两个不同的类：

```java
// 符合单一职责原则的类 - 用户信息管理
public class UserInformationManager {
    public void manageUserInformation(User user) {
        // 代码实现...
    }
}

// 符合单一职责原则的类 - 用户权限验证
public class UserPermissionValidator {
    public boolean validateUserPermissions(User user) {
        // 代码实现...
        return false;
    }
}
```

现在，`UserInformationManager` 类负责用户信息的管理，而 `UserPermissionValidator` 类负责用户权限的验证。这样的设计使得每个类都有一个清晰的职责，提高了代码的可维护性。如果未来需要修改用户信息管理的逻辑，不会影响到权限验证的部分，反之亦然。这符合单一职责原则的设计理念。

### 优缺点

#### 优点

**降低类的复杂度**。一个类只复杂一项职责，逻辑就比负责多个职责的简单。

**提高类的可读性**。复杂度降低，可读性自然提高。

**提高系统的可维护性**。可读性提高，自然就容易维护了。

**变更引起的风险降低**。变更是必然的，如果单一职责原则遵守得好，当修改一个功能室，可以显著降低对其他功能的影响。

#### 缺点

一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；

单一职责原则提出了一个编写程序的标准，用”职责“或”变化原因“来衡量接口或类设计得是否优良，但是”职责“或”变化原因“都是不可度量 的，因项目而已，因环境而已，因而有时候会有争议。



## 2. O开闭原则（**Open Closed Principle**）

### 概念

开闭原则（Open/Closed Principle - OCP）要求软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改。简而言之，**对于系统的扩展应该是通过添加新代码来实现的，而不是通过修改现有代码。**

### 例子

下面是一个简单的例子，说明开闭原则的应用。假设有一个图形绘制程序，可以绘制不同类型的图形（如圆形和矩形）。最初的设计如下：

```java
// 初始设计，违反开闭原则
public class DrawingProgram {
    public void drawShape(Shape shape) {
        if (shape instanceof Circle) {
            drawCircle((Circle) shape);
        } else if (shape instanceof Rectangle) {
            drawRectangle((Rectangle) shape);
        }
        // 如果新增图形类型，需要修改这里的代码
    }

    private void drawCircle(Circle circle) {
        // 绘制圆形的逻辑
    }

    private void drawRectangle(Rectangle rectangle) {
        // 绘制矩形的逻辑
    }
}

public class Circle implements Shape {
    // 圆形的属性和方法
}

public class Rectangle implements Shape {
    // 矩形的属性和方法
}

public interface Shape {
    // 图形的通用接口
}

```

上述设计违反了开闭原则，因为如果新增一种图形，例如三角形，就需要修改 `DrawingProgram` 类的代码，违背了不修改现有代码的原则。

符合开闭原则的设计应该是可以轻松扩展的。下面是一个改进后的设计：

```java
// 符合开闭原则的设计
public class DrawingProgram {
    public void drawShape(Shape shape) {
        shape.draw();
    }
}

public class Circle implements Shape {
    // 圆形的属性和方法

    @Override
    public void draw() {
        // 绘制圆形的逻辑
    }
}

public class Rectangle implements Shape {
    // 矩形的属性和方法

    @Override
    public void draw() {
        // 绘制矩形的逻辑
    }
}

public class Triangle implements Shape {
    // 三角形的属性和方法

    @Override
    public void draw() {
        // 绘制三角形的逻辑
    }
}
public interface Shape {
    void draw();
}
```

### 优缺点

#### 优点

抽象带来软件实体的可复用性的提高。

基于抽象矿建进行拓展实现新功能，提高了软件实体的可拓展性。

软件实体的可维护性的提高。

#### 缺点

设计难度比较大。

## 3.L里氏代换原则(**Liskov Substitution Principle**)

### 概念

里氏替换原则（Liskov Substitution Principle - LSP）是面向对象设计中的一个重要原则，**它规定子类必须能够替换掉其父类并且仍然保持程序的正确性**。简而言之，如果一个类是其子类，那么它们可以互换使用而不影响程序的正确性。

扩展：

+ 子类可以拓展父类的功能，但不能修改父类已有的功能，如果修改了父类已有的功能，可能导致父类定义的功能在子类覆盖后不适用。
+ 重载父类的方法时，子类的方法形参应该比父类更宽松。
+ 实现父类的抽象方法时，子类的方法输出结果应该比父类更加严格。
+ 子类可以有自已独特的私有方法，但是需要注意的是，如果子类不能完全实现父类的方法，或者父类的某一些方法在子类中已经不适用，这种情况则建议断开父子关系，使用组合等方式代替继承出现。

### 例子

下面是一个例子，说明里氏替换原则的应用。考虑一个图形计算面积的场景，有一个 `Rectangle` 类和一个 `Square` 类，其中 `Square` 是 `Rectangle` 的子类，符合正常的面向对象继承关系。然而，如果不小心违反了里氏替换原则，可能会导致问题。

```java
// 违反里氏替换原则的设计
class Rectangle {
    protected int width;
    protected int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int calculateArea() {
        return width * height;
    }
}

class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width);
    }

    @Override
    public void setHeight(int height) {
        super.setHeight(height);
        super.setWidth(height);
    }
}

public class AreaCalculator {
    public static void main(String[] args) {
        Rectangle rectangle = new Square();
        rectangle.setWidth(5);
        rectangle.setHeight(10);

        int area = rectangle.calculateArea();
        System.out.println("Area: " + area); // 输出 Area: 100，但实际期望是 Area: 50
    }
}

```

在上述例子中，`Square` 类继承自 `Rectangle` 类，但重写了父类的 `setWidth` 和 `setHeight` 方法，导致在使用父类引用时，通过这些方法设置宽度和高度的行为变得不一致。

这个设计违反了里氏替换原则，因为在父类的使用场景中（如 `AreaCalculator` 中），替换成子类对象后导致了不符合预期的行为。符合里氏替换原则的设计应该保持一致的行为，确保子类可以无缝替换父类而不引起问题。在这种情况下，可能需要重新考虑类的设计，以确保继承关系符合业务逻辑和里氏替换原则。

### 优缺点

#### 优点

+ 合理地用类的继承关系，提高了代码的复用性。
+ 通过建立抽象，运行过程中具体实现取代抽象，保证了系统的可拓展性。
+ 只要继承父类就拥有父类的全部属性和方法，这样减少了代码重复创建量共享了代码。

## 4.I接口隔离原则(**Interface Segregation Principle**)

### 概念

接口隔离原则（Interface Segregation Principle - ISP）**要求一个类对另一个类的依赖应该建立在最小的接口上，而不应该强迫一个类实现它用不到的接口**。简而言之，一个类不应该被强迫去依赖它不使用的方法。

人话：建立单一的接口，不要建立臃肿庞大的接口。接口尽量细化，接口中的方法尽量少。

接口定义：

+ 实例接口：Java中的一个类，表示对一个类型事物的描述
+ 类接口：Java中interface关键字定义的接口，表示的是方法的集合

### 例子

以下是一个例子，说明接口隔离原则的应用。考虑一个多媒体播放器的场景，有一个接口 `MediaPlayer` 定义了播放音频和播放视频的方法，以及一个实现了该接口的类 `AdvancedMediaPlayer`，该类实现了更高级的功能。

```java
// 违反接口隔离原则的设计
interface MediaPlayer {
    void playAudio();
    void playVideo();
}

class AdvancedMediaPlayer implements MediaPlayer {
    @Override
    public void playAudio() {
        // 实现播放音频的逻辑
    }

    @Override
    public void playVideo() {
        // 实现播放视频的逻辑
    }
}
```

在上述设计中，`AdvancedMediaPlayer` 实现了 `MediaPlayer` 接口，但问题是，某些场景中我们可能只需要使用音频功能而不需要视频功能。如果有一个只关心音频的类，它仍然需要实现 `playVideo` 方法，这就违反了接口隔离原则。

改进的设计如下：

```java
// 符合接口隔离原则的设计
interface AudioPlayer {
    void playAudio();
}

interface VideoPlayer {
    void playVideo();
}

class AdvancedMediaPlayer implements AudioPlayer, VideoPlayer {
    @Override
    public void playAudio() {
        // 实现播放音频的逻辑
    }

    @Override
    public void playVideo() {
        // 实现播放视频的逻辑
    }
}
```

在改进后的设计中，将 `MediaPlayer` 接口拆分为两个接口：`AudioPlayer` 和 `VideoPlayer`。`AdvancedMediaPlayer` 类实现了这两个接口，这样任何只关心音频或视频的类可以选择性地实现相应的接口，而不用强制实现不需要的方法。

这样的设计更符合接口隔离原则，使得类的接口更加精细化，每个类只需要依赖它真正需要的接口。这有助于减少对无关功能的依赖，提高代码的可维护性和灵活性。

### 优缺点

#### 优点

+ 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
+ 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
+ 如果接口的粒度大小定义合理，能够保证系统的稳定性；
+ 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
+ 能减少项目工程中的代码余。

#### 缺点

+ 接口拆分比较灵活，依赖具体业务场景和具体需求，需要一定的经验。
+ 对于较为简单的场景，接口隔离原则可能在一定程度上增加开发量。
+ 日常开发过程中可能会遇到同事间意见难以统一。

## 5.D依赖倒转原则(**Dependence Inversion Principle**)

### 概念

依赖倒置原则（Dependency Inversion Principle - DIP）是面向对象设计的原则之一，它要求高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，而是细节应该依赖于抽象。简而言之，**高层模块和低层模块都应该依赖于抽象**。

人话：对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。

### 例子

以下是一个简单的例子，说明依赖倒置原则的应用。考虑一个电灯的场景，有一个 `Switch` 类用于控制灯的开关，以及一个 `Bulb` 类用于表示灯泡。在不遵循依赖倒置原则的设计中，`Switch` 类直接依赖于 `Bulb` 类。

```java
// 违反依赖倒置原则的设计
class Bulb {
    public void turnOn() {
        System.out.println("Bulb turned on");
    }

    public void turnOff() {
        System.out.println("Bulb turned off");
    }
}

class Switch {
    private Bulb bulb;

    public Switch(Bulb bulb) {
        this.bulb = bulb;
    }

    public void turnOn() {
        bulb.turnOn();
    }

    public void turnOff() {
        bulb.turnOff();
    }
}

```

在上述设计中，`Switch` 类直接依赖于 `Bulb` 类，这意味着如果需要更换灯泡的实现，就需要修改 `Switch` 类的代码。这违反了依赖倒置原则。

改进的设计如下：

```java
// 符合依赖倒置原则的设计
interface Switchable {
    void turnOn();

    void turnOff();
}

class Bulb implements Switchable {
    @Override
    public void turnOn() {
        System.out.println("Bulb turned on");
    }

    @Override
    public void turnOff() {
        System.out.println("Bulb turned off");
    }
}

class Switch {
    private Switchable device;

    public Switch(Switchable device) {
        this.device = device;
    }

    public void turnOn() {
        device.turnOn();
    }

    public void turnOff() {
        device.turnOff();
    }
}

```

### 优缺点

#### 优点

+ 可以减少类之间的耦合，提高系统稳定性。
+ 提高代码复用率，减少维护成本。
+ 两个类之间有依赖关系，只要制定出两者之间的接口就可以独立开发，并且项目之间的单元测试可以独立开发，典型应用就是TDD(测试驱动开发)。

#### 缺点

+ 抽象需要新增接口或者抽象类，并且抽象在代码中需要找到具体实现类看具体执行的逻辑。
+ 简单情况下有可能会增加代码量和工作成本。



## 6.C合成复用原则(**Composite Reuse Principle**)

### 概念

**调通过组合或聚合而不是继承来实现代码的复用**。这意味着在设计中，**应该优先选择将已有的类组合到新的类中，而不是通过继承来获得已有类的行为**。以下是一个简单的例子：

### 举例

假设有一个基本的图形类 `Shape`，它有一个绘制方法 `draw`：

```java
public class Shape {
    public void draw() {
        // 绘制图形的通用逻辑
        System.out.println("Drawing a shape");
    }
}
```

现在，我们想要创建一个新的类 `ColoredShape`，表示有颜色的图形，并且能够绘制。一个直观的想法是通过继承来实现：

```java
// 错误的实现，违反了合成复用原则
public class ColoredShape extends Shape {
    private String color;

    public ColoredShape(String color) {
        this.color = color;
    }

    // 这里继承了 draw 方法，但是并没有添加颜色相关的逻辑
    // 因此违反了合成复用原则，应该通过组合来解决
}
```

这种方式违反了合成复用原则，因为 `ColoredShape` 继承了 `Shape` 类，但并没有真正的复用 `Shape` 类的行为，而且可能导致不必要的复杂性。

改进的方式是通过组合 `Shape` 类，而不是继承。我们可以将 `Shape` 对象作为 `ColoredShape` 的成员：

```java
// 通过组合实现合成复用原则
public class ColoredShape {
    private Shape shape;
    private String color;

    public ColoredShape(Shape shape, String color) {
        this.shape = shape;
        this.color = color;
    }

    // 通过调用组合的 Shape 对象的 draw 方法，实现复用
    public void draw() {
        shape.draw();
        System.out.println("Color: " + color);
    }
}

```

现在，`ColoredShape` 类通过组合 `Shape` 类的对象，实现了对 `Shape` 的复用，并且添加了额外的颜色信息，而不是通过继承来复用 `draw` 方法。这种方式更加灵活，减少了对继承的依赖，符合合成复用原则。

## 7.D迪米特法则(**Law of Demeter**)

### 概念

也被称为最少知识原则，强调一个对象应该对其他对象有尽可能少的了解，**即一个对象不应该直接调用另一个对象的内部细节**(<mark>就是不能直接调用其setter、getter来获取或设置其内部细节，而是应该通过‘朋友’的外部接口来操作</mark>)。这有助于减少对象之间的耦合，提高系统的灵活性和维护性。只与直接朋友进行通信。

朋友：

1. 类中的成员变量
2. 方法的形式参数类型 
3. 方法的返回值类型

### 举例

不满足迪米特法则的例子：

```java
// 不满足迪米特法则的调用方类
public class School {
    public void enrollStudent(Student student) {
        // 注册学生逻辑
        student.setEnrolled(true);
        // 其他操作...
    }
}

// 被调用者类
public class Student {
    private boolean isEnrolled;

    public void setEnrolled(boolean isEnrolled) {
        this.isEnrolled = isEnrolled;
    }
}

```

在这个例子中，`School` 类的 `enrollStudent` 方法直接设置了 `Student` 类的 `isEnrolled` 属性，违反了迪米特法则，因为 `School` 类过多地了解了 `Student` 类的内部实现。

满足迪米特法则的例子：

```java
// 满足迪米特法则的调用方类
public class School {
    public void enrollStudent(Student student) {
        // 注册学生逻辑
        student.enroll();
        // 其他操作...
    }
}

// 被调用者类
public class Student {
    private boolean isEnrolled;

    public void enroll() {
        // 处理注册逻辑
        this.isEnrolled = true;
        // 其他操作...
    }
}

```

在这个例子中，`School` 类调用 `Student` 类的 `enroll` 方法，而不是直接设置 `Student` 类的内部状态。这样，`School` 类不再需要了解 `Student` 类的具体实现细节，符合迪米特法则的原则。

# 4,创建者模式(单元见丑工)

## 4.1 ★★单例模式

### 1.饿汉式-方式1(静态变量方式)

```java
public class Singleton{
    //静态变量方式
    private static Singleton instance = new Singleton();
    //私有构造方法
    private Singleton(){
        
    }
    //对外提供静态方法获取该实例
    public static Singleton getInstance(){
        return instance;
    }
}
```

### 2.饿汉式-方式2(静态代码块方式)

```java
public class Singleton{
    //静态变量方式
    private static Singleton instance;
    //静态代码块
    static {
        instance = new Singleton();
    }
    //私有构造方法
    private Singleton(){
        
    }
    //对外提供静态方法获取该实例
    public static Singleton getInstance(){
        return instance;
    }
}
```

### 3.饿汉式-枚举类

```java
enum Singleton{
    INSTANCE;
}
```

### 4.懒汉式-方式1(线程不安全)

```java
public class Singleton{
    //静态变量方式
    private static Singleton instance;
    //私有构造方法
    private Singleton(){
        
    }
    //对外提供静态方法获取该实例
    public static Singleton getInstance(){
        if(instance==null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 5.懒汉式-方式2(线程安全)

```java
public class Singleton{
    //静态变量方式
    private static Singleton instance;
    //私有构造方法
    private Singleton(){
        
    }
    //对外提供静态方法获取该实例
    public static synchronized Singleton getInstance(){
        if(instance==null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 6.懒汉式-方式3(双重检查锁线程安全）

```java
public class Singleton{
    //静态变量方式
    private static volatile Singleton instance;
    //私有构造方法
    private Singleton(){
        
    }
    //对外提供静态方法获取该实例
    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instance = new Singleton();
                }
            }
            
        }
        return instance;
    }
}
```

### 7.懒汉式-方式(静态内部类方式)

```java
public class Singleton{
    //私有构造方法
    private Singleton(){}
    private static class SingletonHolder{
        private static final Singleton INSTANCE = new Singleton;
    }
    //对外提供静态方法获取该实例
    public static Singleton getInstance(){
        return SingletonHolder.INSTANCE;
    }
}
```



## 4.2 ★原型模式

原型模式就是使用一个已经存在的对象进行克隆，简化创建的流出。

原型模式的克隆分为浅克隆和深克隆。

+ 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
+ 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

### 浅克隆

```java
class Student {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class Citation implements Cloneable {
    private Student student;

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    @Override
    public Citation clone() throws CloneNotSupportedException {
        return (Citation) super.clone();
    }

    public void showCitation() {
        System.out.println(student.getName() + "获得奖状");
    }
}

public class CitationTest {
    public static void main(String[] args) throws Exception {
        Citation citation1 = new Citation();
        Student student1 = new Student();
        student1.setName("张三");
        citation1.setStudent(student1);


        Citation citation2 = citation1.clone();
        citation2.getStudent().setName("李四");
        citation1.showCitation();//李四获得奖状
        citation2.showCitation();//李四获得奖状
    }
}
```

### 深克隆

```java
class Student implements Serializable {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class Citation implements Cloneable, Serializable {
    private Student student;

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    @Override
    public Citation clone() throws CloneNotSupportedException {
        return (Citation) super.clone();
    }

    public void showCitation() {
        System.out.println(student.getName() + "获得奖状");
    }
}

public class CitationTest {
    public static void main(String[] args) throws Exception {
        Citation citation1 = new Citation();
        Student student1 = new Student();
        student1.setName("张三");
        citation1.setStudent(student1);

        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("D:/a.txt"));
        objectOutputStream.writeObject(citation1);
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("D:/a.txt"));
        Citation citation2 = (Citation) objectInputStream.readObject();
        citation2.getStudent().setName("李四");

        citation1.showCitation();//张三获得奖状
        citation2.showCitation();//李四获得奖状
    }
}
```

## 4.3 ★建造者模式

建造者模式是一种常用的软件设计模式，它用于创建一个复杂对象的各个部分，并最终构建出完整的对象。在Java中，建造者模式通常用于创建具有多个可选参数的对象，使得对象的构建过程更加清晰和灵活。

### 基本概念

建造者模式通常涉及以下几个角色：

1. **产品（Product）**：最终要构建的复杂对象。
2. **建造者（Builder）**：定义创建产品的接口，包括为产品的每个部分提供创建方法。
3. **具体建造者（Concrete Builder）**：实现Builder接口，提供构建产品的具体实现。它负责创建产品的各个组成部分，并在最后组装产品。
4. **指挥者（Director）**：负责安排已有模块的顺序，然后告诉Builder开始建造。
5. **客户端（Client）**：使用Director和Builder来创建对象。

### 代码

```java
public class Bike {
    private String frame;
    private String seat;

    public String getFrame() {
        return frame;
    }

    public void setFrame(String frame) {
        this.frame = frame;
    }

    public String getSeat() {
        return seat;
    }

    public void setSeat(String seat) {
        this.seat = seat;
    }
}
public abstract class Builder {
    //声明bike类型的变量，并进行赋值
    protected Bike bike = new Bike();

    public abstract void buildFrame();

    public abstract void buildSeat();

    public abstract Bike createBike();
}
/**
 * 指挥者类
 */
public class Director {
    private Builder builder;
    public Director(Builder builder) {
        this.builder = builder;
    }
    //组装自行车的功能
    public Bike construct() {
        builder.buildFrame();
        builder.buildSeat();
        return builder.createBike();
    }
}

public class OfoBuilder extends Builder {
    @Override
    public void buildFrame() {
        bike.setFrame("钛合金车架");
    }

    @Override
    public void buildSeat() {
        bike.setSeat("橡胶座位");
    }

    @Override
    public Bike createBike() {
        return bike;
    }
}
public class Client {
    public static void main(String[] args) {
        Director director = new Director(new MobileBuilder());
        Bike bike = director.construct();
        System.out.println("bike.getFrame() = " + bike.getFrame());
        System.out.println("bike.getSeat() = " + bike.getSeat());

    }
}

```

### 常见BeanBuilder代码

```java
public class Computer {
    private String screen;
    private String memory;
    private String cpu;
    private String motherBoard;

    private Computer(Builder builder) {
        this.screen = builder.screen;
        this.memory = builder.memory;
        this.cpu = builder.cpu;
        this.motherBoard = builder.motherBoard;
    }

    @Override
    public String toString() {
        return "Computer{" +
                "screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", cpu='" + cpu + '\'' +
                ", motherBoard='" + motherBoard + '\'' +
                '}';
    }

    public static final class Builder {
        private String screen;
        private String memory;
        private String cpu;
        private String motherBoard;

        public Builder screen(String screen) {
            this.screen = screen;
            return this;
        }

        public Builder memory(String memory) {
            this.memory = memory;
            return this;
        }

        public Builder cpu(String cpu) {
            this.cpu = cpu;
            return this;
        }

        public Builder motherBoard(String motherBoard) {
            this.motherBoard = motherBoard;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }
}
```

### 工厂方法模式VS建造者模式

工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。

我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。

###  抽象工厂模式VS建造者模式

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。

建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。

如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。



## 4.4 简单工厂模式(不包含，编程习惯)

### 不使用工厂模式

#### 代码

```java
abstract class Coffee {
    public abstract String getName();
    //加糖
    public void addSugar(){
        System.out.println("加糖");
    }
    //加奶
    public void addMilk(){
        System.out.println("加奶");
    }
}
class AmericaCoffee extends Coffee{
    @Override
    public String getName() {
        return "美式咖啡";
    }

}
class LatteCoffee extends Coffee{

    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}

class CoffeeStore {
    public Coffee orderCoffee(String type){
        Coffee coffee = null;
        if ("america".equals(type)){
            coffee = new AmericaCoffee();
        }else if ("latte".equals(type)){
            coffee = new LatteCoffee();
        }else {
            throw new RuntimeException("您点的咖啡没有");
        }
        //加配料
        coffee.addMilk();
        coffee.addSugar();
        return coffee;
    }
}

public class Client {
    public static void main(String[] args) {
        CoffeeStore coffeeStore = new CoffeeStore();
        Coffee coffee = coffeeStore.orderCoffee("latte");
        System.out.println(coffee.getName());
    }
}
```

#### 缺点

当新添加一种新的咖啡类型，就会导致我们扩展 `Coffee`类并修改 `CoffeeStore`类，这样导致 `CoffeeStore`与具体的 `Coffee`的耦合。

### 使用简单工厂模式

#### 代码

```java
abstract class Coffee {
    public abstract String getName();

    //加糖
    public void addSugar() {
        System.out.println("加糖");
    }

    //加奶
    public void addMilk() {
        System.out.println("加奶");
    }
}

class AmericaCoffee extends Coffee {
    @Override
    public String getName() {
        return "美式咖啡";
    }

}

class LatteCoffee extends Coffee {

    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}

class SimpleCoffeeFactory {
    public Coffee createCoffee(String type) {
        Coffee coffee = null;
        if ("america".equals(type)) {
            coffee = new AmericaCoffee();
        } else if ("latte".equals(type)) {
            coffee = new LatteCoffee();
        } else {
            throw new RuntimeException("您点的咖啡没有");
        }
        return coffee;
    }
}

class CoffeeStore {
    public Coffee orderCoffee(String type) {
        SimpleCoffeeFactory coffeeFactory = new SimpleCoffeeFactory();
        Coffee coffee = coffeeFactory.createCoffee(type);
        //加配料
        coffee.addMilk();
        coffee.addSugar();
        return coffee;
    }
}

public class Client {
    public static void main(String[] args) {
        CoffeeStore coffeeStore = new CoffeeStore();
        Coffee coffee = coffeeStore.orderCoffee("latte");
        System.out.println(coffee.getName());
    }
}
```

#### 优缺点

##### 优点

将 `CoffeeStore`中与`Coffee`具体实现的耦合代码移动到了`SimpleCoffeeFactory`中，解除了其耦合。新添加一个`Coffee`的具体实现类，就不会修改`CoffeeStore`中的代码，在这个角度上满足了开闭原则。

##### 缺点

但是引入了新的耦合，就是`SimpleCoffeeFactory`与具体`Coffee`之间的耦合，新添加一个`Coffee`类就会导致修改`SimpleCoffeeFactory`的代码，违反了开闭原则。

#### 扩展(静态简单工厂)

```java
abstract class Coffee {
    public abstract String getName();

    //加糖
    public void addSugar() {
        System.out.println("加糖");
    }

    //加奶
    public void addMilk() {
        System.out.println("加奶");
    }
}

class AmericaCoffee extends Coffee {
    @Override
    public String getName() {
        return "美式咖啡";
    }

}

class LatteCoffee extends Coffee {

    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}

class SimpleCoffeeFactory {
    public static Coffee createCoffee(String type) {
        Coffee coffee = null;
        if ("america".equals(type)) {
            coffee = new AmericaCoffee();
        } else if ("latte".equals(type)) {
            coffee = new LatteCoffee();
        } else {
            throw new RuntimeException("您点的咖啡没有");
        }
        return coffee;
    }
}

class CoffeeStore {
    public Coffee orderCoffee(String type) {
        Coffee coffee = SimpleCoffeeFactory.createCoffee(type);
        //加配料
        coffee.addMilk();
        coffee.addSugar();
        return coffee;
    }
}

public class Client {
    public static void main(String[] args) {
        CoffeeStore coffeeStore = new CoffeeStore();
        Coffee coffee = coffeeStore.orderCoffee("latte");
        System.out.println(coffee.getName());
    }
}
```



## 4.4 简单工厂(配置文件+反射）

```java
public class SimpleBeanFactory {
    static Map<String, Bean> map = new HashMap();

    static {
        Properties properties = new Properties();
        InputStream inputStream = SimpleCoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");
        try {
            properties.load(inputStream);
            Set<Object> keys = properties.keySet();
            //遍历key集合
            for (Object key : keys) {

                String className = properties.getProperty((String) key);
                Class<?> clazz = Class.forName(className);
                Bean bean = (Bean) clazz.newInstance();
                map.put((String) key, bean);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    public static Bean createBean(String type) {
        return map.get(type);
    }
}
```

## 4.4★★ 抽象工厂模式(多个产品创建)

### 代码

```java
/**
 * 咖啡类产品
 */
abstract class Coffee {
    public abstract String getName();

    //加糖
    public void addSugar() {
        System.out.println("加糖");
    }

    //加奶
    public void addMilk() {
        System.out.println("加奶");
    }
}
class AmericaCoffee extends Coffee {
    @Override
    public String getName() {
        return "美式咖啡";
    }
}

class LatteCoffee extends Coffee {

    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}

/**
 * 甜品类产品
 */
abstract class Dessert {
    public abstract void show();
}

class MatchaMousse extends Dessert {
    @Override
    public void show() {
        System.out.println("抹茶慕斯");
    }
}

class Tiramisu extends Dessert {
    @Override
    public void show() {
        System.out.println("提拉米苏");
    }
}

/**
 * 抽象工厂类
 */
interface DessertFactory {
    Coffee createCoffee();

    Dessert createDessert();
}

class AmericaDessertFactory implements DessertFactory {
    @Override
    public Coffee createCoffee() {
        return new AmericaCoffee();
    }

    @Override
    public Dessert createDessert() {
        return new MatchaMousse();
    }
}

class ItalyDessertFactory implements DessertFactory {
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }

    @Override
    public Dessert createDessert() {
        return new Tiramisu();
    }
}



public class Client {
    public static void main(String[] args) {
//        DessertFactory factory = new AmericaDessertFactory();
        DessertFactory factory = new ItalyDessertFactory();
        Coffee coffee = factory.createCoffee();
        System.out.println(coffee.getName());
        Dessert dessert = factory.createDessert();
        dessert.show();
    }
}
```

### 优缺点

#### 优点

当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

#### 缺点

当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

### 使用场景

* 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。

* 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。

* 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。

## 4.5 ★★工厂方法模式

核心类:工厂直接规定工厂接口的方法,返回值为抽象类或接口

### 代码

```java
abstract class Coffee {
    public abstract String getName();

    //加糖
    public void addSugar() {
        System.out.println("加糖");
    }

    //加奶
    public void addMilk() {
        System.out.println("加奶");
    }
}

class AmericaCoffee extends Coffee {
    @Override
    public String getName() {
        return "美式咖啡";
    }

}

class LatteCoffee extends Coffee {

    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}

interface CoffeeFactory {
    Coffee createCoffee();
}

class AmericaCoffeeFactory implements CoffeeFactory {

    @Override
    public Coffee createCoffee() {
        return new AmericaCoffee();
    }
}

class LatteCoffeeFactory implements CoffeeFactory {
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }
}

class CoffeeStore {

    CoffeeFactory coffeeFactory;

    public void setCoffeeFactory(CoffeeFactory coffeeFactory) {
        this.coffeeFactory = coffeeFactory;
    }

    public Coffee orderCoffee() {
        Coffee coffee = coffeeFactory.createCoffee();
        coffee.addMilk();
        coffee.addSugar();
        return coffee;
    }
}

public class Client {
    public static void main(String[] args) {
        CoffeeStore coffeeStore = new CoffeeStore();
        coffeeStore.setCoffeeFactory(new AmericaCoffeeFactory());
        Coffee coffee = coffeeStore.orderCoffee();
        System.out.println(coffee.getName());
    }
}
```

### 优缺点

#### 优点

完全符合开闭原则

当我们新添加一种 `Coffee`类的话，只需要新增加 CoffeeFactory的一个实现类和 `Coffee`的实现类。

#### 缺点

每增加一个类就多一个工厂类，增加了系统的复杂度。

# 5,结构型模式(代氏想祖乔装外)

结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为`类结构型模式`和`对象结构型模式`，前者采用`继承机制`来组织接口和类，后者釆用`组合`或`聚合`来组合对象。

由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。

结构型模式分为以下 7 种：

* 代理模式
* 适配器模式
* 享元模式
* 组合模式
* 桥接模式
* 装饰者模式
* 外观模式

## 5.1☆★★代理模式

### 静态代理模式

核心类:代理类,实现要代理的接口,并持有该接口实现者(被代理对象)的实例

```java
interface SellTickets {
    void sell();
}
class TrainStation implements SellTickets{
    @Override
    public void sell() {
        System.out.println("火车站卖票");
    }
}
//核心类:实现接口,并持有接口实现者
class ProxyPoint implements SellTickets{
    private TrainStation trainStation = new TrainStation();


    @Override
    public void sell() {
        System.out.println("代售点收取服务费");
        trainStation.sell();
    }
}
public class Client {
    public static void main(String[] args) {
        ProxyPoint proxyPoint  = new ProxyPoint();
        proxyPoint.sell();
    }
}
```

### JDK动态代理

```java
//卖票接口
public interface SellTickets {
    void sell();
}

//火车站  火车站具有卖票功能，所以需要实现SellTickets接口
public class TrainStation implements SellTickets {

    public void sell() {
        System.out.println("火车站卖票");
    }
}

//代理工厂，用来创建代理对象
public class ProxyFactory {

    private TrainStation station = new TrainStation();

    public SellTickets getProxyObject() {
        //使用Proxy获取代理对象
        /*
            newProxyInstance()方法参数说明：
                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可
                Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口
                InvocationHandler h ： 代理对象的调用处理程序
         */
        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {
                    /*
                        InvocationHandler中invoke方法参数说明：
                            proxy ： 代理对象
                            method ： 对应于在代理对象上调用的接口方法的 Method 实例
                            args ： 代理对象调用接口方法时传递的实际参数
                     */
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                        System.out.println("代理点收取一些服务费用(JDK动态代理方式)");
                        //执行真实对象
                        Object result = method.invoke(station, args);
                        return result;
                    }
                });
        return sellTickets;
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        //获取代理对象
        ProxyFactory factory = new ProxyFactory();
        
        SellTickets proxyObject = factory.getProxyObject();
        proxyObject.sell();
    }
}
```



### GGLib动态代理

```java
//火车站
public class TrainStation {

    public void sell() {
        System.out.println("火车站卖票");
    }
}

//代理工厂
public class ProxyFactory implements MethodInterceptor {

    private TrainStation target = new TrainStation();

    public TrainStation getProxyObject() {
        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数
        Enhancer enhancer =new Enhancer();
        //设置父类的字节码对象
        enhancer.setSuperclass(target.getClass());
        //设置回调函数
        enhancer.setCallback(this);
        //创建代理对象
        TrainStation obj = (TrainStation) enhancer.create();
        return obj;
    }

    /*
        intercept方法参数说明：
            o ： 代理对象
            method ： 真实对象中的方法的Method实例
            args ： 实际参数
            methodProxy ：代理对象中的方法的method实例
     */
    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("代理点收取一些服务费用(CGLIB动态代理方式)");
        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);
        return result;
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        //创建代理工厂对象
        ProxyFactory factory = new ProxyFactory();
        //获取代理对象
        TrainStation proxyObject = factory.getProxyObject();

        proxyObject.sell();
    }
}
```

## 5.2☆★★适配器模式

### 定义

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

### 适配器模式角色

适配器模式（Adapter）包含以下主要角色：

* 目标（Target）接口(待适配对象)：当前系统业务所期待的接口，它可以是抽象类或接口。
* 适配者（Adaptee）类(被适配对象)：它是被访问和适配的现存组件库中的组件接口。
* 适配器（Adapter）类(适配器)：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

### 类适配器模式

核心类:适配器类,实现被适配接口,继承要适配的接口的实现类

<img src="https://gitee.com/pirmingham/gallery/raw/master/images/适配器模式.png" style="zoom:80%;" />

```java
//SD卡的接口
public interface SDCard {
    //读取SD卡方法
    String readSD();
    //写入SD卡功能
    void writeSD(String msg);
}

//SD卡实现类
public class SDCardImpl implements SDCard {
    public String readSD() {
        String msg = "sd card read a msg :hello word SD";
        return msg;
    }

    public void writeSD(String msg) {
        System.out.println("sd card write msg : " + msg);
    }
}

//电脑类
public class Computer {

    public String readSD(SDCard sdCard) {
        if(sdCard == null) {
            throw new NullPointerException("sd card null");
        }
        return sdCard.readSD();
    }
}

//TF卡接口
public interface TFCard {
    //读取TF卡方法
    String readTF();
    //写入TF卡功能
    void writeTF(String msg);
}

//TF卡实现类
public class TFCardImpl implements TFCard {

    public String readTF() {
        String msg ="tf card read msg : hello word tf card";
        return msg;
    }

    public void writeTF(String msg) {
        System.out.println("tf card write a msg : " + msg);
    }
}

//核心类:实现被适配接口,继承要适配的实现类
//定义适配器类（SD兼容TF）
public class SDAdapterTF extends TFCardImpl implements SDCard {

    public String readSD() {
        System.out.println("adapter read tf card ");
        return readTF();
    }

    public void writeSD(String msg) {
        System.out.println("adapter write tf card");
        writeTF(msg);
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        Computer computer = new Computer();
        SDCard sdCard = new SDCardImpl();
        System.out.println(computer.readSD(sdCard));

        System.out.println("------------");

        SDAdapterTF adapter = new SDAdapterTF();
        System.out.println(computer.readSD(adapter));
    }
}
```

类适配器模式违背了`合成复用原则`。类适配器是客户类有一个接口规范的情况下可用，反之不可用(区分术语：待适配的类，SDCard的实现类，被适配的类，TFCard的实现类。类适配器是在待适配类有一个接口规范即SDCard下可用，如果没有该接口，那么适配器类就要同时实现SDCard类的实现类还有TFCard的实现类，Java不允许同时实现两个类，固类适配器有局限性)。

### 对象适配器模式(推荐)

核心类:适配器类实现被适配的接口,持有要适配接口,接口实例由构造函数提供

<img src="https://gitee.com/pirmingham/gallery/raw/master/images/对象适配器模式.png" style="zoom:80%;" />

```java
//核心类:适配器类实现被适配的接口,持有适配接口的实现类,
//创建适配器对象（SD兼容TF）
public class SDAdapterTF  implements SDCard {

    private TFCard tfCard;

    public SDAdapterTF(TFCard tfCard) {
        this.tfCard = tfCard;
    }

    public String readSD() {
        System.out.println("adapter read tf card ");
        return tfCard.readTF();
    }

    public void writeSD(String msg) {
        System.out.println("adapter write tf card");
        tfCard.writeTF(msg);
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        Computer computer = new Computer();
        SDCard sdCard = new SDCardImpl();
        System.out.println(computer.readSD(sdCard));

        System.out.println("------------");
        SDAdapterTF adapter = new SDAdapterTF(new TFCardImpl());
        System.out.println(computer.readSD(adapter));
    }
}
```



### 接口适配器模式

假设我们有一个窗口（`Window`）接口，它定义了多种与窗口相关的事件方法，如 `windowOpened`, `windowClosing`, `windowClosed`, 等。我们将创建一个 `WindowAdapter` 类，它实现了 `Window` 接口并提供了所有这些方法的默认实现。然后，我们可以创建一个具体的类，比如 `MyWindow`，它继承自 `WindowAdapter` 并重写我们感兴趣的方法。

```java
// 窗口事件接口
interface Window {
    void windowOpened();
    void windowClosing();
    void windowClosed();
    // ... 其他窗口事件方法
}

// 窗口适配器类，提供默认实现
abstract class WindowAdapter implements Window {
    public void windowOpened() {}
    public void windowClosing() {}
    public void windowClosed() {}
    // ... 其他方法的默认实现
}

// 具体的窗口类
class MyWindow extends WindowAdapter {
    public void windowOpened() {
        System.out.println("Window Opened");
    }

    public void windowClosing() {
        System.out.println("Window Closing");
    }
}

```

在这个例子中，`MyWindow` 类只关心 `windowOpened` 和 `windowClosing` 方法。通过继承 `WindowAdapter`，它可以避免实现 `Window` 接口中的所有方法。

## 5.3享元模式[未理解]

### 定义

享元模式（Flyweight Pattern）是一种结构型设计模式，旨在减少对象数量以减少内存占用，提高性能，特别适用于处理大量相似对象的场景。这种模式通过共享尽可能多的相似状态（即内部状态）来实现这一目标。

### 核心概念

享元模式的核心在于区分内部状态和外部状态：

1. **内部状态**（Intrinsic State）：这些状态存储在享元对象内部，不会随环境的改变而有所不同。内部状态可以共享。
2. **外部状态**（Extrinsic State）：这些状态随环境的改变而改变，不能共享。外部状态必须由客户端保存，并在享元对象被使用时提供给享元对象。

### 享元模式的组件

享元模式通常涉及以下几个组件：

1. **Flyweight（享元）**：这是一个接口或抽象类，声明了具有内部状态的方法。
2. **ConcreteFlyweight（具体享元）**：实现享元接口，并存储内部状态。享元对象是可共享的，其内部状态是不变的。
3. **UnsharedConcreteFlyweight（非共享具体享元）**：并非所有的享元对象都需要被共享。非共享具体享元通常不遵循享元模式。
4. **FlyweightFactory（享元工厂）**：负责创建和管理享元对象。当客户端请求一个享元对象时，享元工厂提供一个已创建的实例或创建一个新的实例。

![image-20231217165600996](https://gitee.com/pirmingham/gallery/raw/master/images/享元设计模式.png)

### 代码

```java
import java.util.HashMap;
import java.util.Map;

// 享元接口
// 定义了享元对象的公共方法
interface Flyweight {
    void operation(String extrinsicState);
}

// 具体享元类
// 实现享元接口，并包含内部状态（intrinsicState）
class ConcreteFlyweight implements Flyweight {
    private String intrinsicState; // 内部状态

    // 构造函数，初始化内部状态
    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    // 实现operation方法，extrinsicState为外部状态
    @Override
    public void operation(String extrinsicState) {
        System.out.println("ConcreteFlyweight: " + intrinsicState + ", " + extrinsicState);
    }
}

// 非共享具体享元类
// 不被共享的享元对象
class UnsharedConcreteFlyweight implements Flyweight {
    private String allState; // 包含所有状态

    // 构造函数，初始化状态
    public UnsharedConcreteFlyweight(String allState) {
        this.allState = allState;
    }

    // 实现operation方法
    @Override
    public void operation(String extrinsicState) {
        System.out.println("UnsharedConcreteFlyweight: " + allState + ", " + extrinsicState);
    }
}

// 享元工厂
// 负责创建和管理享元对象
class FlyweightFactory {
    private Map<String, Flyweight> flyweights = new HashMap<>(); // 存储享元对象的映射

    // 获取享元对象的方法
    // 如果对象不存在，则创建一个新的享元对象
    public Flyweight getFlyweight(String key) {
        if (!flyweights.containsKey(key)) {
            flyweights.put(key, new ConcreteFlyweight(key));
        }
        return flyweights.get(key);
    }
}
```

### 应用场景

享元模式适用于以下场景：

- 程序需要生成大量相似的对象，这些对象中大部分状态都可以被外部化。
- 对象的数量太多，以至于无法高效地存储。
- 对象的大多数状态都可以变为外部状态。

### 优缺点

**优点**：

- 大幅减少对象的数量，节省内存。
- 可以更有效地利用计算资源。

**缺点**：

- 增加了系统的复杂性，需要区分内部和外部状态。
- 需要确保享元对象的状态不会被错误地共享。

### 实际应用

享元模式在实际应用中非常常见，特别是在需要缓存或共享大量相似对象的场景中。例如，Java中的`String`池、图形编辑器中的图形对象、数据库连接池等都是享元模式的应用实例。通过共享对象，这些应用能够在处理大量对象时保持较低的内存占用和较高的性能。

## 5.4组合模式

### 定义

又名整体部分模式，用以将一组相似对象抽象出一种单一对象。组合模式是以树形结构组合出具体结构，每个节点可能有多种实现，针对不同实现抽象出共有的方法。

### 结构或组件

<img src="https://gitee.com/pirmingham/gallery/raw/master/images/组合模式2.png" style="zoom:80%;" />

抽象根节点（Component）：所有的一级、二级、三级菜单的抽象类

树枝节点（Composite）：一级、二级菜单

叶子节点（Leaf）：三级菜单项，叶子节点

### 代码实现

<img src="https://gitee.com/pirmingham/gallery/raw/master/images/组合模式3.png" style="zoom:80%;" />

抽象根节点

```java
//菜单组件  不管是菜单还是菜单项，都应该继承该类
public abstract class MenuComponent {

    protected String name;
    protected int level;

    //添加菜单
    public void add(MenuComponent menuComponent){
        throw new UnsupportedOperationException();
    }

    //移除菜单
    public void remove(MenuComponent menuComponent){
        throw new UnsupportedOperationException();
    }

    //获取指定的子菜单
    public MenuComponent getChild(int i){
        throw new UnsupportedOperationException();
    }

    //获取菜单名称
    public String getName(){
        return name;
    }

    public void print(){
        throw new UnsupportedOperationException();
    }
}

```

树枝节点

```java
public class Menu extends MenuComponent {

    private List<MenuComponent> menuComponentList;

    public Menu(String name,int level){
        this.level = level;
        this.name = name;
        menuComponentList = new ArrayList<MenuComponent>();
    }

    @Override
    public void add(MenuComponent menuComponent) {
        menuComponentList.add(menuComponent);
    }

    @Override
    public void remove(MenuComponent menuComponent) {
        menuComponentList.remove(menuComponent);
    }

    @Override
    public MenuComponent getChild(int i) {
        return menuComponentList.get(i);
    }

    @Override
    public void print() {

        for (int i = 1; i < level; i++) {
            System.out.print("--");
        }
        System.out.println(name);
        for (MenuComponent menuComponent : menuComponentList) {
            menuComponent.print();
        }
    }
}
```

叶子节点

```java
public class MenuItem extends MenuComponent {

    public MenuItem(String name,int level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void print() {
        for (int i = 1; i < level; i++) {
            System.out.print("--");
        }
        System.out.println(name);
    }
}
```

### 优点

* 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
* 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
* 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
* 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。

### 使用场景

组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈 现等树形结构数据的操作。

## 5.5★桥接模式

### 定义

定义：将类的功能层次结构与类的实现层次结构，通过委托的方式（即功能层次结构持有实现层次结构的引用，并调用实现层次的方法）来实现。

### 结构

桥接（Bridge）模式包含以下主要角色：

* 抽象化（Abstraction）角色[功能层次结构] ：定义抽象类，并包含一个对实现化对象的引用。
* 扩展抽象化（Refined  Abstraction）角色 [功能层次结构]：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
* 实现化（Implementor）角色 [实现层次结构]：定义实现化角色的接口，供扩展抽象化角色调用。
* 具体实现化（Concrete Implementor）角色[实现层次结构] ：给出实现化角色接口的具体实现。

### 代码

#### 操作系统接口[实现层次结构]

```java
interface OperatingSystem {
    void start();
}
```

#### 具体操作系统[实现层次结构]

```java
class Windows implements OperatingSystem {
    public void start() {
        System.out.println("Starting Windows...");
    }
}

class Linux implements OperatingSystem {
    public void start() {
        System.out.println("Starting Linux...");
    }
}
```

#### 电脑抽象类[功能层次结构]

核心类:功能层次类持有实现层次类,实现层次类实例由构造方法提供

```java
abstract class Computer {
    protected OperatingSystem os;

    public Computer(OperatingSystem os) {
        this.os = os;
    }

    public abstract void boot();
}
```

#### 具体电脑类型[功能层次结构]

```java
class Desktop extends Computer {
    public Desktop(OperatingSystem os) {
        super(os);
    }

    public void boot() {
        System.out.println("Booting Desktop...");
        os.start();
    }
}

class Laptop extends Computer {
    public Laptop(OperatingSystem os) {
        super(os);
    }

    public void boot() {
        System.out.println("Booting Laptop...");
        os.start();
    }
}
```

#### 使用桥接模式

```java
public class BridgePatternDemo {
    public static void main(String[] args) {
        Computer desktop = new Desktop(new Windows());
        desktop.boot();

        Computer laptop = new Laptop(new Linux());
        laptop.boot();
    }
}
```

在这个例子中，`Computer`类（抽象化）通过一个`OperatingSystem`的引用（实现化）来启动电脑。这样，我们可以独立地切换电脑类型（桌面电脑、笔记本电脑）和操作系统（Windows、Linux），而无需为每种组合创建单独的类。这正是桥接模式的优势所在。

### 功能层次结构与实现层次结构

在这个Java例子中，功能层次结构和实现层次结构是桥接模式的两个关键组成部分，它们帮助我们理解这种设计模式的工作原理：

#### 功能层次结构

功能层次结构提供了抽象的操作，它定义了对象可以做什么。在我们的例子中，这对应于电脑的不同类型：

1. **抽象基类**：`Computer`
   - 这是功能层次结构的基础。`Computer`定义了所有电脑共有的基本功能，即`boot()`方法。
2. **具体实现类**：
   - `Desktop` 和 `Laptop`
   - 这些类扩展了`Computer`类，提供了特定类型电脑的具体实现。例如，`Desktop`类和`Laptop`类可能有不同的启动流程，这在它们的`boot()`方法中体现。

#### 实现层次结构

实现层次结构提供了功能层次结构中定义的操作的具体实现。在我们的例子中，这对应于操作系统：

1. **接口**：`OperatingSystem`
   - 这个接口定义了实现层次结构的基本操作，即`start()`方法。
2. **具体实现类**：
   - `Windows` 和 `Linux`
   - 这些类实现了`OperatingSystem`接口，提供了具体的操作系统启动逻辑。例如，`Windows`类有其特定的启动过程，同样`Linux`类也有。

在桥接模式中，这两个层次结构是分离的：功能层次结构（`Computer`、`Desktop`、`Laptop`）关注于“做什么”，而实现层次结构（`OperatingSystem`、`Windows`、`Linux`）关注于“怎么做”。通过在`Computer`类中包含`OperatingSystem`的引用，我们建立了一个“桥”，将这两个层次结构连接起来。这样，我们就可以独立地更改电脑的类型或操作系统，而不会影响到另一方。

### 委托

在桥接模式的Java例子中，委托是一个关键概念。委托指的是一个对象将其某些职责交给另一个对象来处理。在我们的例子中，委托主要出现在`Computer`类（即功能层次结构）如何使用`OperatingSystem`类（即实现层次结构）来实现部分功能。

具体来说，在`Computer`类中，我们有一个`OperatingSystem`的引用，这个引用是通过构造函数传入的。在`Computer`类的`boot`方法中，`Computer`类不直接实现启动操作系统的全部逻辑，而是委托给了`OperatingSystem`对象的`start`方法。

例如，在`Desktop`类中：

```java
public void boot() {
    System.out.println("Booting Desktop...");
    os.start();  // 委托给OperatingSystem
}
```

这里的`os.start()`就是一个委托的操作。`Desktop`类并不关心操作系统是如何启动的，它只知道需要启动操作系统。具体的启动逻辑则是由`OperatingSystem`的具体实现（如`Windows`或`Linux`）来完成的。

这样的设计允许我们更加灵活地处理不同的操作系统，因为我们可以轻松地替换或修改`OperatingSystem`的实现，而不需要更改`Computer`类或其子类。这正是桥接模式通过委托实现解耦的一个典型例子。

## 5.6☆★★装饰者模式

核心类:装饰者类继承父类并持有父类,实例由构造方法提供;

```java
abstract class Food {
    private String desc;
    private Double price;

    public Food() {
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    public abstract Double cost();
}

class FriedRice extends Food {

    public FriedRice() {
        setDesc("炒饭");
        setPrice(10D);
    }

    @Override
    public Double cost() {
        return getPrice();
    }
}
class FriedNoodles extends Food {
    public FriedNoodles() {
        setDesc("炒面");
        setPrice(12D);
    }

    @Override
    public Double cost() {
        return getPrice();
    }
}
//核心类:继承父类并持有父类
class Decorator extends Food {
    private Food food;


    public Decorator(Food food) {
        this.food = food;
    }

    @Override
    public Double cost() {
        return getPrice() + food.cost();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + food.getDesc();
    }
}
class Bacon extends Decorator{
    public Bacon(Food food) {
        super(food);
        setDesc("培根");
        setPrice(4D);
    }

}
class Egg extends Decorator {
    public Egg(Food food) {
        super(food);
        setPrice(2D);
        setDesc("鸡蛋");
    }

}
public class Client {
    public static void main(String[] args) {
        FriedRice friedRice = new FriedRice();
        System.out.println(friedRice.getDesc() + " " + friedRice.cost());
        Food eggFriedRice = new Egg(friedRice);
        System.out.println(eggFriedRice.getDesc() + " " + eggFriedRice.cost());
        Food baconEggFriedRice = new Bacon(eggFriedRice);
        System.out.println(baconEggFriedRice.getDesc() + " " + baconEggFriedRice.cost());
        Food food = new Egg(new Bacon(new FriedNoodles()));
        System.out.println(food.getDesc()+" "+food.cost());
    }
}

```

## 5.7★★外观模式

核心类:facade持有子系统的实例,并提供相应门面方法控制子系统

```java
package design.pattern.ch03structural.section07.facade;

class Light {
    public void on() {
        System.out.println("light on");
    }

    public void off() {
        System.out.println("light off");
    }
}

class AirConditioner {
    public void on() {
        System.out.println("air conditioner on");
    }

    public void off() {
        System.out.println("air conditioner off");
    }
}
//核心类:facade持有子系统的实例,并提供相应门面方法控制子系统
class SmartAppliancesFacade {
    private Light light;
    private AirConditioner airConditioner;

    public SmartAppliancesFacade() {
        light = new Light();
        airConditioner = new AirConditioner();
    }

    public void Listen(String Listen) {
        if (Listen.contains("on")) {
            airConditioner.on();
            light.on();
        } else if (Listen.contains("off")) {
            airConditioner.off();
            light.off();
        }
    }
}

public class Client {
    public static void main(String[] args) {
        SmartAppliancesFacade smartAppliancesFacade = new SmartAppliancesFacade();
        smartAppliancesFacade.Listen("on");
    }
}

```

# 6,行为型模式

## 6.1访问者



## 6.2中介者



## 6.3☆观察者★★

```java
interface Observer {
    void update(String message);
}

interface Subject {
    void addObserver(Observer observer);

    void removeObserver(Observer observer);

    void notify(String message);
}

class WexinUser implements Observer {
    private String name;

    public WexinUser(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " 听到了: " + message);
    }
}

//核心类:主题类持有观察者的list实例,并提供将信息遍历发给所有观察者的方法;
class WexinSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();

    @Override
    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notify(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}


public class Client {
    public static void main(String[] args) {
        Subject wexinSubject = new WexinSubject();
        wexinSubject.addObserver(new WexinUser("彭俊辉"));
        wexinSubject.addObserver(new WexinUser("何安平"));
        wexinSubject.addObserver(new WexinUser("王建建"));
        wexinSubject.addObserver(new WexinUser("谢天天"));
        wexinSubject.notify("来打我呀!");
    }
}
```

## 6.4☆模版方法★★

```java
abstract class AbstractClass {
    public void manLife() {
        born();
        live();
        death();
    }

    public void born() {
        System.out.println("出生");
    }

    public abstract void live();

    public void death() {
        System.out.println("死亡");
    }
}

class MingHam extends AbstractClass {

    @Override
    public void live() {
        System.out.println("mingham快乐地生活");
    }
}

public class Client {
    public static void main(String[] args) {
        AbstractClass manLive = new MingHam();
        manLive.manLife();
    }
}
```

## 6.5命令★★



## 6.6☆策略★★

```java
interface Strategy {
    void show();
}

//核心类,salesMan持有策略实例,构造函数赋值或setter设值
class SalesMan {
    private Strategy strategy;

    public SalesMan(Strategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void salesManShow() {
        strategy.show();
    }
}

class StrategyA implements Strategy {
    @Override
    public void show() {
        System.out.println("买一赠一");
    }
}

class StrategyB implements Strategy {
    @Override
    public void show() {
        System.out.println("慢200减50");
    }
}

public class Client {
    public static void main(String[] args) {
        SalesMan salesMan = new SalesMan(new StrategyA());
        salesMan.salesManShow();
        salesMan.setStrategy(new StrategyB());
        salesMan.salesManShow();
    }
}
```

## 6.7☆职责链

```java
abstract class Handler {
    protected Handler nextHandler;

    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }

    public abstract void handleRequest(int priority, String request);
}
class ConcreteHandlerA extends Handler {
    @Override
    public void handleRequest(int priority, String request) {
        if (priority <= 1) {
            System.out.println("Handler A is handling the request: " + request);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(priority, request);
        } else {
            System.out.println("No handler can handle the request: " + request);
        }
    }
}

class ConcreteHandlerB extends Handler {
    @Override
    public void handleRequest(int priority, String request) {
        if (priority <= 2) {
            System.out.println("Handler B is handling the request: " + request);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(priority, request);
        } else {
            System.out.println("No handler can handle the request: " + request);
        }
    }
}

class ConcreteHandlerC extends Handler {
    @Override
    public void handleRequest(int priority, String request) {
        if (priority <= 3) {
            System.out.println("Handler C is handling the request: " + request);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(priority, request);
        } else {
            System.out.println("No handler can handle the request: " + request);
        }
    }
}

public class Client {
    public static void main(String[] args) {
        Handler handlerA = new ConcreteHandlerA();
        Handler handlerB = new ConcreteHandlerB();
        Handler handlerC = new ConcreteHandlerC();

        handlerA.setNextHandler(handlerB);
        handlerB.setNextHandler(handlerC);

        handlerA.handleRequest(2, "This is a medium priority request.");
        handlerA.handleRequest(3, "This is a high priority request.");
    }
}
```

## 6.8☆迭代器



## 6.9备忘录



## 6.10解释器



## 6.11状态★
